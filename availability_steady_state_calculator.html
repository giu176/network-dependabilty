<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Availability Planner — Steady-State Calculator</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #131a2b;
      --accent: #5dd6ff;
      --accent2: #9effa1;
      --text: #e8f0ff;
      --muted: #a7b1c7;
      --danger: #ff6b6b;
      --warn: #ffd36b;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Inter", system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: 320px 1fr 360px;
      grid-template-rows: auto 1fr;
      gap: 12px;
      padding: 12px;
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-radius: 12px;
      background: linear-gradient(180deg, #11182b, #0c1224);
      border: 1px solid #1b2440;
    }

    header .title {
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    header .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin-top: 2px;
    }

    .btns button {
      margin-left: 8px;
    }

    aside,
    main {
      background: var(--panel);
      border: 1px solid #1b2440;
      border-radius: 12px;
      padding: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid #1b2440;
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .graph-head {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .graph-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .graph-toolbar button.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    .graph-toolbar select {
      min-width: 180px;
    }

    .graph-toolbar input[type='text'] {
      min-width: 120px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #1f2d54;
      background: #0f1830;
      color: var(--text);
    }

    .graph-canvas-wrapper {
      position: relative;
      border: 1px dashed #23305a;
      border-radius: 12px;
      background: #0d142a;
      overflow: hidden;
    }

    svg#graphCanvas {
      width: 100%;
      height: 320px;
      display: block;
    }

    .graph-edge {
      stroke: #3a4f8a;
      stroke-width: 2;
      marker-end: url(#arrowhead);
    }

    .graph-node circle,
    .graph-node rect {
      fill: #16224a;
      stroke: #2f4da0;
      stroke-width: 2;
    }

    .graph-node.merge circle {
      fill: #1b274e;
      stroke: #45c0ff;
    }

    .graph-node.terminal .terminal-shape {
      fill: rgba(93, 214, 255, 0.08);
      stroke: var(--accent);
      stroke-width: 2;
    }

    .graph-node.terminal-end .terminal-shape {
      stroke: var(--accent2);
      fill: rgba(158, 255, 161, 0.08);
    }

    .graph-node.terminal .terminal-role {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      fill: var(--accent);
    }

    .graph-node.terminal-end .terminal-role {
      fill: var(--accent2);
    }

    .graph-node text {
      fill: var(--text);
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .graph-node.pending circle {
      stroke: var(--accent2);
      stroke-width: 3;
    }

    .graph-node.pending .terminal-shape {
      stroke: var(--accent2);
      stroke-width: 3;
    }

    .graph-node:hover circle {
      stroke: var(--accent);
    }

    .graph-node.terminal:hover .terminal-shape {
      stroke: var(--accent);
    }

    .graph-node.terminal-end:hover .terminal-shape {
      stroke: var(--accent2);
    }

    .graph-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .graph-meta .graph-list {
      background: #101a36;
      border: 1px solid #1f2d54;
      border-radius: 10px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 150px;
      overflow-y: auto;
    }

    .graph-meta h3 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
    }

    .graph-meta .item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }

    .graph-meta .item span {
      flex: 1;
    }

    h2 {
      font-size: 16px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input,
    select,
    button,
    textarea {
      background: #0e1530;
      color: var(--text);
      border: 1px solid #2a355e;
      border-radius: 8px;
      padding: 8px;
      font-family: inherit;
      font-size: 13px;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: 2px solid var(--accent);
    }

    button {
      cursor: pointer;
      font-weight: 600;
    }

    button.primary {
      background: linear-gradient(180deg, #193a65, #12294b);
      border-color: #244c86;
    }

    button.ghost {
      background: #0b1227;
    }

    button.danger {
      background: #2b0f17;
      border-color: #61202c;
      color: #ffd6da;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .component-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .component-card {
      background: #101730;
      border: 1px solid #1f2950;
      border-radius: 10px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .component-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .component-name {
      font-weight: 600;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #0e1735;
      border: 1px solid #283463;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #b9c6ff;
    }

    .component-stats {
      font-size: 12px;
      color: #c9d6ff;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 12px;
    }

    .actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    main {
      overflow-y: auto;
    }

    .stage-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .stage-card {
      background: #101730;
      border: 1px solid #1f2950;
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .stage-head {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 160px auto;
      gap: 8px;
      align-items: center;
    }

    .stage-stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 12px;
      font-size: 12px;
      color: #c9d6ff;
    }

    select[multiple] {
      min-height: 120px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #0f1838;
      border: 1px solid #2a355e;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 11px;
      color: #9fb2ff;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 6px 14px;
      font-size: 14px;
    }

    .stats-label {
      color: var(--muted);
      font-size: 13px;
    }

    .value {
      font-variant-numeric: tabular-nums;
    }

    .status-ok {
      color: var(--accent2);
      font-weight: 600;
    }

    .status-warn {
      color: var(--warn);
      font-weight: 600;
    }

    .scroll {
      overflow-y: auto;
    }

    .formula {
      background: rgba(93, 214, 255, 0.08);
      border: 1px solid rgba(93, 214, 255, 0.2);
      border-radius: 10px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      color: #cfe9ff;
      white-space: pre-wrap;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #2a355e;
      background: #0f1838;
      color: #b7c6ff;
      font-size: 12px;
    }

    .empty-hint {
      font-style: italic;
      color: var(--muted);
      font-size: 13px;
    }

    @media (max-width: 1200px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        overflow-y: auto;
        padding: 12px;
      }

      aside,
      main {
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">📈 Availability Planner — Steady-State Calculator</div>
        <div class="subtitle">Use MTBF &amp; MTTR inputs to derive component uptime, then combine them in series/parallel stages.</div>
      </div>
      <div class="btns">
        <button id="resetAll" class="danger">Reset All</button>
      </div>
    </header>

    <aside class="left">
      <div class="section">
        <h2>➕ Add Component</h2>
        <div>
          <label for="nameInput">Component Name</label>
          <input id="nameInput" type="text" placeholder="e.g., Core Router" />
        </div>
        <div>
          <label for="mtbfInput">Mean Time Between Failures (hours)</label>
          <input id="mtbfInput" type="number" min="0" step="0.01" placeholder="e.g., 1200" />
        </div>
        <div>
          <label for="mttrInput">Mean Time To Repair (hours)</label>
          <input id="mttrInput" type="number" min="0" step="0.01" placeholder="e.g., 2" />
        </div>
        <div class="actions">
          <button id="saveComponent" class="primary">Add Component</button>
          <button id="cancelEdit" class="ghost" style="display:none">Cancel</button>
        </div>
        <div class="hint">
          Availability is computed as <span class="pill">A = MTBF / (MTBF + MTTR)</span> per the steady-state formula. MTTR includes
          corrective repair time only.
        </div>
      </div>

      <div class="section">
        <h2>📦 Components</h2>
        <div id="componentList" class="component-list"></div>
        <div id="componentEmpty" class="empty-hint">Add components to start planning your network.</div>
      </div>
    </aside>

    <main>
      <div class="section">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
          <h2>🧮 System Stages</h2>
          <button id="addStage" class="ghost">Add Stage</button>
        </div>
        <div class="hint">
          Build the network as an ordered set of stages. Each stage can be a <strong>series</strong> chain (all components must be up)
          or a <strong>parallel</strong> redundant cluster (any component can carry the load). Stage results automatically feed into the
          system availability computation.
        </div>
        <div id="stageList" class="stage-list"></div>
        <div id="stageEmpty" class="empty-hint">Create your first stage to model the topology.</div>
      </div>

      <div class="section">
        <div class="graph-head">
          <h2>🗺️ Availability Graph</h2>
          <div class="graph-toolbar">
            <select id="graphComponentSelect">
              <option value="">Select component…</option>
            </select>
            <input id="graphStartLabel" type="text" placeholder="Start label" style="width:120px" />
            <button id="graphAddStart" class="ghost">Place Start</button>
            <button id="graphAddNode" class="ghost">Add Node</button>
            <button id="graphAddEdge" class="ghost">Add Edge</button>
            <button id="graphAddMerge" class="ghost">Add Merge Dot</button>
            <input id="graphEndLabel" type="text" placeholder="End label" style="width:120px" />
            <button id="graphAddEnd" class="ghost">Place End</button>
            <button id="graphCancel" class="ghost">Cancel</button>
          </div>
        </div>
        <div class="hint">
          Use the availability graph to express stage and redundancy relationships visually. Begin by placing start and end
          terminals, then wire components or merge dots between them. Node positions are draggable; edges determine ordering, and
          merge dots behave as always-on connectors.
        </div>
        <div class="graph-canvas-wrapper">
          <svg id="graphCanvas" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div id="graphEmpty" class="empty-hint">Place start/end terminals and nodes to visualize the topology.</div>
        <div class="graph-meta">
          <div>
            <h3>Nodes</h3>
            <div id="graphNodeList" class="graph-list"></div>
          </div>
          <div>
            <h3>Edges</h3>
            <div id="graphEdgeList" class="graph-list"></div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>📊 System Availability</h2>
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <label for="yearHours" style="margin:0">Hours in Evaluation Window</label>
          <input id="yearHours" type="number" min="1" step="1" value="8760" style="width:120px" />
          <span class="badge">Change for 24h/weekly/annual downtime reporting</span>
        </div>
        <div class="stats-grid">
          <div class="stats-label">Steady-State Availability</div>
          <div id="systemAvailability" class="value">—</div>
          <div class="stats-label">Unavailability (Q = 1 − A)</div>
          <div id="systemUnavailability" class="value">—</div>
          <div class="stats-label">Expected Downtime</div>
          <div id="systemDowntime" class="value">—</div>
          <div class="stats-label">Downtime Breakdown</div>
          <div id="systemDowntimeDetail" class="value">—</div>
          <div class="stats-label">Status</div>
          <div id="systemStatus" class="value">—</div>
        </div>
      </div>
    </main>

    <aside class="right">
      <div class="section">
        <h2>📐 Key Formulas</h2>
        <div class="formula">
A_component = MTBF / (MTBF + MTTR)

Series stage: A_stage = ∏ A_i
Parallel stage: A_stage = 1 − ∏ (1 − A_i)

Expected downtime (hours) = (1 − A) × window_hours
        </div>
        <div class="hint">
          Steady-state availability reflects the long-run uptime fraction for repairable components under constant failure/repair rates.
          Series combinations multiply availabilities, while parallel redundancy multiplies unavailabilities. All calculations assume
          statistically independent components.
        </div>
      </div>

      <div class="section scroll" style="flex:1">
        <h2>🗒️ Notes</h2>
        <div class="hint">
          <ul style="margin:0 0 0 18px; padding:0; line-height:1.6">
            <li>MTBF represents the mean up-time (same as MTTF in many specs). MTTR captures the mean corrective downtime.</li>
            <li>Availability is mode-agnostic: whether the device is active/standby or load-sharing, treat MTTR as the time until service is restored.</li>
            <li>For redundancy, only include components that truly provide alternate service paths. Shared infrastructure may break independence.</li>
            <li>Adjust the evaluation window to translate unavailability into outage minutes per day, week, or year.</li>
            <li>Pair this tool with reliability (no-repair) analysis when sizing mission success probabilities.</li>
          </ul>
        </div>
      </div>
    </aside>
  </div>

  <script>
    const componentListEl = document.getElementById('componentList');
    const componentEmptyEl = document.getElementById('componentEmpty');
    const stageListEl = document.getElementById('stageList');
    const stageEmptyEl = document.getElementById('stageEmpty');
    const nameInput = document.getElementById('nameInput');
    const mtbfInput = document.getElementById('mtbfInput');
    const mttrInput = document.getElementById('mttrInput');
    const saveComponentBtn = document.getElementById('saveComponent');
    const cancelEditBtn = document.getElementById('cancelEdit');
    const addStageBtn = document.getElementById('addStage');
    const resetAllBtn = document.getElementById('resetAll');
    const yearHoursInput = document.getElementById('yearHours');

    const systemAvailabilityEl = document.getElementById('systemAvailability');
    const systemUnavailabilityEl = document.getElementById('systemUnavailability');
    const systemDowntimeEl = document.getElementById('systemDowntime');
    const systemDowntimeDetailEl = document.getElementById('systemDowntimeDetail');
    const systemStatusEl = document.getElementById('systemStatus');

    const graphCanvas = document.getElementById('graphCanvas');
    const graphComponentSelect = document.getElementById('graphComponentSelect');
    const graphAddStartBtn = document.getElementById('graphAddStart');
    const graphAddNodeBtn = document.getElementById('graphAddNode');
    const graphAddEdgeBtn = document.getElementById('graphAddEdge');
    const graphAddMergeBtn = document.getElementById('graphAddMerge');
    const graphAddEndBtn = document.getElementById('graphAddEnd');
    const graphCancelBtn = document.getElementById('graphCancel');
    const graphEmptyEl = document.getElementById('graphEmpty');
    const graphNodeListEl = document.getElementById('graphNodeList');
    const graphEdgeListEl = document.getElementById('graphEdgeList');
    const graphStartLabelInput = document.getElementById('graphStartLabel');
    const graphEndLabelInput = document.getElementById('graphEndLabel');

    const components = [];
    const stages = [];
    const graphNodes = [];
    const graphEdges = [];
    let nextComponentId = 1;
    let nextStageId = 1;
    let nextGraphNodeId = 1;
    let nextGraphEdgeId = 1;
    let editingComponentId = null;
    let graphMode = null;
    let pendingEdgeStartId = null;
    let dragNodeId = null;
    let dragOffset = { x: 0, y: 0 };
    let mergeDotCount = 1;
    let derivedGraphStages = [];

    function parseFloatOrNull(value) {
      const num = parseFloat(value);
      return Number.isFinite(num) ? num : null;
    }

    function computeAvailability(mtbf, mttr) {
      const total = mtbf + mttr;
      if (!Number.isFinite(total) || total <= 0 || mtbf < 0 || mttr < 0) return null;
      return mtbf / total;
    }

    function hoursToHuman(hours) {
      if (!Number.isFinite(hours)) return '—';
      const days = hours / 24;
      const minutes = hours * 60;
      if (hours >= 24) {
        return `${hours.toFixed(2)} h (~${days.toFixed(2)} d)`;
      }
      if (minutes >= 60) {
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        return `${h} h ${m} m`;
      }
      return `${minutes.toFixed(1)} min`;
    }

    function formatPct(value) {
      if (!Number.isFinite(value)) return '—';
      return `${(value * 100).toFixed(4)}%`;
    }

    function formatDecimal(value, digits = 6) {
      if (!Number.isFinite(value)) return '—';
      return value.toFixed(digits);
    }

    function setGraphMode(mode) {
      graphMode = mode;
      if (mode !== 'add-edge') {
        pendingEdgeStartId = null;
      }
      refreshGraphModeButtons();
    }

    function refreshGraphModeButtons() {
      const buttons = [
        { btn: graphAddStartBtn, mode: 'add-start-terminal' },
        { btn: graphAddNodeBtn, mode: 'add-node' },
        { btn: graphAddEdgeBtn, mode: 'add-edge' },
        { btn: graphAddMergeBtn, mode: 'add-merge' },
        { btn: graphAddEndBtn, mode: 'add-end-terminal' },
      ];
      buttons.forEach(({ btn, mode }) => {
        if (!btn) return;
        btn.classList.toggle('active', graphMode === mode);
      });
      if (graphCancelBtn) {
        graphCancelBtn.classList.toggle('active', Boolean(graphMode) || pendingEdgeStartId !== null);
      }
    }

    function getSVGCoordinates(evt) {
      const rect = graphCanvas.getBoundingClientRect();
      const scaleX = 800 / rect.width;
      const scaleY = 400 / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY,
      };
    }

    function getComponentById(id) {
      return components.find((c) => c.id === id) || null;
    }

    function getGraphNodeLabel(node) {
      if (node.type === 'terminal') {
        const role = node.role === 'start' ? 'Start' : 'End';
        return node.label ? `${role}: ${node.label}` : `${role} Terminal`;
      }
      if (node.type === 'merge') return node.label;
      const comp = getComponentById(node.componentId);
      return comp ? comp.name : 'Unknown';
    }

    function getGraphNodeAvailability(node) {
      if (node.type === 'terminal') return 1;
      if (node.type === 'merge') return 1;
      const comp = getComponentById(node.componentId);
      return comp ? comp.availability : null;
    }

    function getTerminalNode(role) {
      return graphNodes.find((node) => node.type === 'terminal' && node.role === role) || null;
    }

    function upsertTerminalNode(role, label, x, y) {
      const existing = getTerminalNode(role);
      const sanitizedLabel = label.trim();
      if (existing) {
        existing.label = sanitizedLabel;
        existing.x = x;
        existing.y = y;
        return existing;
      }
      const node = {
        id: nextGraphNodeId++,
        type: 'terminal',
        role,
        label: sanitizedLabel,
        availability: 1,
        x,
        y,
      };
      graphNodes.push(node);
      return node;
    }

    function refreshGraphComponentSelect() {
      if (!graphComponentSelect) return;
      const previous = graphComponentSelect.value;
      graphComponentSelect.innerHTML = '<option value="">Select component…</option>';
      components.forEach((comp) => {
        const option = document.createElement('option');
        option.value = String(comp.id);
        option.textContent = `${comp.name} (${formatPct(comp.availability)})`;
        if (previous && previous === option.value) {
          option.selected = true;
        }
        graphComponentSelect.appendChild(option);
      });
      if (graphAddNodeBtn) {
        graphAddNodeBtn.disabled = !components.length;
      }
      if (!components.length && graphMode === 'add-node') {
        setGraphMode(null);
      }
    }

    function addGraphNodeFromComponent(componentId, x, y) {
      const comp = getComponentById(componentId);
      if (!comp) {
        alert('Select a valid component before placing a node.');
        return null;
      }
      const node = {
        id: nextGraphNodeId++,
        type: 'component',
        componentId: comp.id,
        x,
        y,
      };
      graphNodes.push(node);
      return node;
    }

    function addMergeDotNode(x, y) {
      const node = {
        id: nextGraphNodeId++,
        type: 'merge',
        label: `Merge ${mergeDotCount++}`,
        x,
        y,
      };
      graphNodes.push(node);
      return node;
    }

    function removeGraphNodeInternal(id) {
      const idx = graphNodes.findIndex((n) => n.id === id);
      if (idx === -1) return;
      const [removed] = graphNodes.splice(idx, 1);
      for (let i = graphEdges.length - 1; i >= 0; i -= 1) {
        if (graphEdges[i].from === id || graphEdges[i].to === id) {
          graphEdges.splice(i, 1);
        }
      }
      if (pendingEdgeStartId === id) {
        pendingEdgeStartId = null;
      }
      if (removed && removed.type === 'terminal') {
        if (removed.role === 'start' && graphStartLabelInput) {
          graphStartLabelInput.value = '';
        }
        if (removed.role === 'end' && graphEndLabelInput) {
          graphEndLabelInput.value = '';
        }
      }
    }

    function deleteGraphNode(id) {
      removeGraphNodeInternal(id);
      refreshGraph();
      computeSystem();
    }

    function deleteGraphEdge(id) {
      const idx = graphEdges.findIndex((e) => e.id === id);
      if (idx === -1) return;
      graphEdges.splice(idx, 1);
      refreshGraph();
      computeSystem();
    }

    function handleCanvasClick(evt) {
      if (evt.target !== graphCanvas) return;
      if (!graphMode) return;
      const coords = getSVGCoordinates(evt);
      if (graphMode === 'add-start-terminal') {
        if (!graphStartLabelInput) return;
        const label = graphStartLabelInput.value.trim();
        if (!label) {
          alert('Provide a label for the start terminal before placing it.');
          return;
        }
        upsertTerminalNode('start', label, coords.x, coords.y);
        setGraphMode(null);
        refreshGraph();
        computeSystem();
        return;
      }
      if (graphMode === 'add-end-terminal') {
        if (!graphEndLabelInput) return;
        const label = graphEndLabelInput.value.trim();
        if (!label) {
          alert('Provide a label for the end terminal before placing it.');
          return;
        }
        upsertTerminalNode('end', label, coords.x, coords.y);
        setGraphMode(null);
        refreshGraph();
        computeSystem();
        return;
      }
      if (graphMode === 'add-node') {
        const selected = graphComponentSelect.value;
        if (!selected) {
          alert('Choose a component before adding a node.');
          return;
        }
        addGraphNodeFromComponent(Number(selected), coords.x, coords.y);
        refreshGraph();
        computeSystem();
        return;
      }
      if (graphMode === 'add-merge') {
        addMergeDotNode(coords.x, coords.y);
        refreshGraph();
        computeSystem();
      }
    }

    function handleEdgeSelection(node) {
      if (graphMode !== 'add-edge') return;
      if (pendingEdgeStartId === node.id) {
        pendingEdgeStartId = null;
        refreshGraph();
        return;
      }
      if (pendingEdgeStartId === null) {
        pendingEdgeStartId = node.id;
        refreshGraph();
        return;
      }
      if (pendingEdgeStartId !== node.id) {
        const start = graphNodes.find((n) => n.id === pendingEdgeStartId);
        if (!start) {
          pendingEdgeStartId = null;
          refreshGraph();
          return;
        }
        const exists = graphEdges.some((e) => e.from === start.id && e.to === node.id);
        if (exists) {
          alert('Edge already exists.');
          pendingEdgeStartId = null;
          refreshGraph();
          return;
        }
        graphEdges.push({ id: nextGraphEdgeId++, from: start.id, to: node.id });
        pendingEdgeStartId = null;
        refreshGraph();
        computeSystem();
      }
    }

    function startNodeDrag(node, evt) {
      if (graphMode === 'add-edge') {
        evt.stopPropagation();
        return;
      }
      evt.preventDefault();
      dragNodeId = node.id;
      const coords = getSVGCoordinates(evt);
      dragOffset = { x: coords.x - node.x, y: coords.y - node.y };
      window.addEventListener('mousemove', dragNodeMove);
      window.addEventListener('mouseup', stopNodeDrag, { once: true });
    }

    function dragNodeMove(evt) {
      if (!dragNodeId) return;
      const node = graphNodes.find((n) => n.id === dragNodeId);
      if (!node) return;
      const coords = getSVGCoordinates(evt);
      node.x = Math.max(20, Math.min(780, coords.x - dragOffset.x));
      node.y = Math.max(20, Math.min(380, coords.y - dragOffset.y));
      renderGraph();
    }

    function stopNodeDrag() {
      dragNodeId = null;
      window.removeEventListener('mousemove', dragNodeMove);
      computeSystem();
    }

    function getTerminalCloudPath(cx, cy) {
      const width = 80;
      const height = 46;
      const left = cx - width / 2;
      const right = cx + width / 2;
      const top = cy - height / 2;
      const bottom = cy + height / 2;
      const control = 14;
      return [
        `M ${left} ${cy}`,
        `C ${left - control} ${top}, ${cx - width / 3} ${top - control}, ${cx} ${top}`,
        `C ${cx + width / 3} ${top - control}, ${right + control} ${top}, ${right} ${cy}`,
        `C ${right + control} ${bottom}, ${cx + width / 3} ${bottom + control}, ${cx} ${bottom}`,
        `C ${cx - width / 3} ${bottom + control}, ${left - control} ${bottom}, ${left} ${cy}`,
        'Z',
      ].join(' ');
    }

    function renderGraph() {
      if (!graphCanvas) return;
      graphCanvas.innerHTML = '';

      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('refX', '5');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      const markerPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      markerPath.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
      markerPath.setAttribute('fill', '#3a4f8a');
      marker.appendChild(markerPath);
      defs.appendChild(marker);
      graphCanvas.appendChild(defs);

      graphEdges.forEach((edge) => {
        const from = graphNodes.find((n) => n.id === edge.from);
        const to = graphNodes.find((n) => n.id === edge.to);
        if (!from || !to) return;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', from.x);
        line.setAttribute('y1', from.y);
        line.setAttribute('x2', to.x);
        line.setAttribute('y2', to.y);
        line.setAttribute('class', 'graph-edge');
        graphCanvas.appendChild(line);
      });

      graphNodes.forEach((node) => {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const classNames = ['graph-node'];
        if (node.type === 'merge') classNames.push('merge');
        if (node.type === 'terminal') classNames.push('terminal', `terminal-${node.role}`);
        if (pendingEdgeStartId === node.id) classNames.push('pending');
        group.setAttribute('class', classNames.join(' '));
        group.dataset.id = node.id;
        if (node.type === 'terminal') {
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', getTerminalCloudPath(node.x, node.y));
          path.setAttribute('class', 'terminal-shape');
          group.appendChild(path);
          const roleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          roleText.setAttribute('x', node.x);
          roleText.setAttribute('y', node.y + 4);
          roleText.setAttribute('class', 'terminal-role');
          roleText.textContent = node.role === 'start' ? 'START' : 'END';
          group.appendChild(roleText);
        } else {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          const radius = node.type === 'merge' ? 10 : 16;
          circle.setAttribute('cx', node.x);
          circle.setAttribute('cy', node.y);
          circle.setAttribute('r', radius);
          group.appendChild(circle);
        }

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', node.x);
        const labelOffset = node.type === 'merge' ? 18 : node.type === 'terminal' ? 36 : 22;
        text.setAttribute('y', node.y - labelOffset);
        text.textContent = getGraphNodeLabel(node);
        group.appendChild(text);

        const availabilityText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        availabilityText.setAttribute('x', node.x);
        const availabilityOffset = node.type === 'merge' ? 20 : node.type === 'terminal' ? 40 : 24;
        availabilityText.setAttribute('y', node.y + availabilityOffset);
        const availability = getGraphNodeAvailability(node);
        availabilityText.textContent = Number.isFinite(availability)
          ? formatPct(availability)
          : '—';
        group.appendChild(availabilityText);

        group.addEventListener('mousedown', (event) => startNodeDrag(node, event));
        group.addEventListener('click', (event) => {
          event.stopPropagation();
          if (graphMode === 'add-edge') {
            handleEdgeSelection(node);
          }
        });

        graphCanvas.appendChild(group);
      });

      graphEmptyEl.style.display = graphNodes.length ? 'none' : 'block';
    }

    function refreshGraphLists() {
      graphNodeListEl.innerHTML = '';
      graphEdgeListEl.innerHTML = '';

      if (!graphNodes.length) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.textContent = 'No nodes defined yet.';
        graphNodeListEl.appendChild(empty);
      } else {
        graphNodes.forEach((node) => {
          const row = document.createElement('div');
          row.className = 'item';
          const span = document.createElement('span');
          if (node.type === 'terminal') {
            const role = node.role === 'start' ? 'Start Terminal' : 'End Terminal';
            const label = node.label ? node.label : 'Unlabeled';
            span.textContent = `${role} — ${label}`;
          } else if (node.type === 'merge') {
            span.textContent = getGraphNodeLabel(node);
          } else {
            span.textContent = `${getGraphNodeLabel(node)} ↔ component`;
          }
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.textContent = 'Delete';
          delBtn.addEventListener('click', () => {
            if (confirm(`Remove node ${getGraphNodeLabel(node)}?`)) {
              deleteGraphNode(node.id);
            }
          });
          row.appendChild(span);
          if (node.type === 'terminal') {
            const moveBtn = document.createElement('button');
            moveBtn.className = 'ghost';
            moveBtn.textContent = 'Move';
            moveBtn.addEventListener('click', () => {
              if (node.role === 'start') {
                if (graphStartLabelInput) {
                  graphStartLabelInput.value = node.label;
                  graphStartLabelInput.focus();
                }
                setGraphMode('add-start-terminal');
              } else {
                if (graphEndLabelInput) {
                  graphEndLabelInput.value = node.label;
                  graphEndLabelInput.focus();
                }
                setGraphMode('add-end-terminal');
              }
            });
            row.appendChild(moveBtn);
          }
          row.appendChild(delBtn);
          graphNodeListEl.appendChild(row);
        });
      }

      if (!graphEdges.length) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.textContent = 'No edges defined yet.';
        graphEdgeListEl.appendChild(empty);
      } else {
        graphEdges.forEach((edge) => {
          const from = graphNodes.find((n) => n.id === edge.from);
          const to = graphNodes.find((n) => n.id === edge.to);
          const row = document.createElement('div');
          row.className = 'item';
          const span = document.createElement('span');
          span.textContent = `${from ? getGraphNodeLabel(from) : 'Unknown'} → ${
            to ? getGraphNodeLabel(to) : 'Unknown'
          }`;
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.textContent = 'Delete';
          delBtn.addEventListener('click', () => {
            if (confirm('Remove this edge?')) {
              deleteGraphEdge(edge.id);
            }
          });
          row.appendChild(span);
          row.appendChild(delBtn);
          graphEdgeListEl.appendChild(row);
        });
      }
    }

    function refreshGraph() {
      renderGraph();
      refreshGraphLists();
      refreshGraphModeButtons();
      if (graphNodes.length < 2 && graphMode === 'add-edge') {
        setGraphMode(null);
      }
    }

    function computeGraphStages(windowHours) {
      derivedGraphStages = [];
      if (!graphNodes.length) {
        return [];
      }
      const startNode = getTerminalNode('start');
      const endNode = getTerminalNode('end');
      if (!startNode || !endNode) {
        return [];
      }

      const nodeById = new Map();
      graphNodes.forEach((node) => {
        nodeById.set(node.id, node);
      });

      const adjacency = new Map();
      const reverseAdjacency = new Map();
      nodeById.forEach((_, id) => {
        adjacency.set(id, []);
        reverseAdjacency.set(id, []);
      });

      graphEdges.forEach((edge) => {
        if (!adjacency.has(edge.from) || !reverseAdjacency.has(edge.to)) return;
        adjacency.get(edge.from).push(edge.to);
        reverseAdjacency.get(edge.to).push(edge.from);
      });

      const forwardReachable = new Set([startNode.id]);
      const forwardQueue = [startNode.id];
      for (let i = 0; i < forwardQueue.length; i += 1) {
        const current = forwardQueue[i];
        const neighbors = adjacency.get(current) || [];
        neighbors.forEach((next) => {
          if (!forwardReachable.has(next)) {
            forwardReachable.add(next);
            forwardQueue.push(next);
          }
        });
      }

      const backwardReachable = new Set([endNode.id]);
      const backwardQueue = [endNode.id];
      for (let i = 0; i < backwardQueue.length; i += 1) {
        const current = backwardQueue[i];
        const neighbors = reverseAdjacency.get(current) || [];
        neighbors.forEach((next) => {
          if (!backwardReachable.has(next)) {
            backwardReachable.add(next);
            backwardQueue.push(next);
          }
        });
      }

      const relevantIds = new Set();
      forwardReachable.forEach((id) => {
        if (backwardReachable.has(id)) {
          relevantIds.add(id);
        }
      });

      if (!relevantIds.has(startNode.id) || !relevantIds.has(endNode.id)) {
        return [];
      }

      const indegree = new Map();
      relevantIds.forEach((id) => {
        indegree.set(id, 0);
      });

      graphEdges.forEach((edge) => {
        if (relevantIds.has(edge.from) && relevantIds.has(edge.to)) {
          indegree.set(edge.to, (indegree.get(edge.to) || 0) + 1);
        }
      });

      const topoQueue = [];
      indegree.forEach((value, id) => {
        if (value === 0) {
          topoQueue.push(id);
        }
      });

      topoQueue.sort((a, b) => {
        if (a === startNode.id) return -1;
        if (b === startNode.id) return 1;
        return 0;
      });

      const indegreeCopy = new Map(indegree);
      const depth = new Map();
      depth.set(startNode.id, 0);

      for (let i = 0; i < topoQueue.length; i += 1) {
        const current = topoQueue[i];
        const currentDepth = depth.get(current) ?? 0;
        const neighbors = adjacency.get(current) || [];
        neighbors.forEach((next) => {
          if (!relevantIds.has(next)) return;
          const nextDepth = Math.max(depth.get(next) ?? 0, currentDepth + 1);
          depth.set(next, nextDepth);
          indegreeCopy.set(next, (indegreeCopy.get(next) || 0) - 1);
          if (indegreeCopy.get(next) === 0) {
            topoQueue.push(next);
          }
        });
      }

      if (!depth.has(endNode.id)) {
        return [];
      }

      const byDepth = new Map();
      relevantIds.forEach((id) => {
        if (!depth.has(id)) return;
        const node = nodeById.get(id);
        if (!node || node.type === 'terminal') return;
        const layer = depth.get(id) ?? 0;
        if (!byDepth.has(layer)) {
          byDepth.set(layer, []);
        }
        byDepth.get(layer).push(node);
      });

      const orderedDepths = Array.from(byDepth.keys()).sort((a, b) => a - b);
      const stageSummaries = [];

      orderedDepths.forEach((layer, index) => {
        const nodes = byDepth.get(layer) || [];
        if (!nodes.length) return;
        const stage = {
          id: `graph-${index + 1}`,
          name: `Graph Stage ${index + 1}`,
          type: nodes.length > 1 ? 'parallel' : 'series',
          nodeIds: nodes.map((node) => node.id),
        };

        const labels = [];
        const availabilities = [];
        let valid = true;
        nodes.forEach((node) => {
          labels.push(getGraphNodeLabel(node));
          const availability = getGraphNodeAvailability(node);
          if (availability === null) {
            valid = false;
          } else {
            availabilities.push(availability);
          }
        });

        let availability = 1;
        if (!availabilities.length || !valid) {
          availability = NaN;
        } else if (stage.type === 'parallel') {
          let product = 1;
          availabilities.forEach((value) => {
            product *= 1 - value;
          });
          availability = 1 - product;
        } else {
          availabilities.forEach((value) => {
            availability *= value;
          });
        }

        const unavailability = Number.isFinite(availability) ? 1 - availability : NaN;
        const downtimeHours = Number.isFinite(unavailability) ? unavailability * windowHours : NaN;

        const summary = {
          stage,
          detail: {
            availability,
            unavailability,
            downtimeHours,
            labels: labels.join(', '),
          },
        };
        stageSummaries.push(summary);
      });

      derivedGraphStages = stageSummaries.map((item) => ({
        name: item.stage.name,
        type: item.stage.type,
        availability: item.detail.availability,
        unavailability: item.detail.unavailability,
        downtimeHours: item.detail.downtimeHours,
        labels: item.detail.labels,
      }));

      return stageSummaries;
    }


    function resetForm() {
      nameInput.value = '';
      mtbfInput.value = '';
      mttrInput.value = '';
      editingComponentId = null;
      saveComponentBtn.textContent = 'Add Component';
      cancelEditBtn.style.display = 'none';
    }

    function upsertComponent() {
      const name = nameInput.value.trim();
      const mtbf = parseFloatOrNull(mtbfInput.value);
      const mttr = parseFloatOrNull(mttrInput.value);

      if (!name || mtbf === null || mttr === null || mtbf < 0 || mttr < 0) {
        alert('Please provide a name, MTBF, and MTTR (all non-negative).');
        return;
      }

      const availability = computeAvailability(mtbf, mttr);
      if (availability === null) {
        alert('MTBF + MTTR must be greater than 0 to compute availability.');
        return;
      }

      if (editingComponentId) {
        const comp = components.find((c) => c.id === editingComponentId);
        if (comp) {
          comp.name = name;
          comp.mtbf = mtbf;
          comp.mttr = mttr;
          comp.availability = availability;
        }
      } else {
        components.push({
          id: nextComponentId++,
          name,
          mtbf,
          mttr,
          availability,
        });
      }

      resetForm();
      refreshComponents();
      refreshStages();
      computeSystem();
    }

    function editComponent(id) {
      const comp = components.find((c) => c.id === id);
      if (!comp) return;
      editingComponentId = comp.id;
      nameInput.value = comp.name;
      mtbfInput.value = comp.mtbf;
      mttrInput.value = comp.mttr;
      saveComponentBtn.textContent = 'Update Component';
      cancelEditBtn.style.display = 'inline-flex';
      nameInput.focus();
    }

    function deleteComponent(id) {
      const idx = components.findIndex((c) => c.id === id);
      if (idx === -1) return;
      components.splice(idx, 1);
      stages.forEach((stage) => {
        stage.componentIds = stage.componentIds.filter((compId) => compId !== id);
      });
      const removedNodes = graphNodes.filter((node) => node.type === 'component' && node.componentId === id).map((node) => node.id);
      removedNodes.forEach((nodeId) => removeGraphNodeInternal(nodeId));
      refreshComponents();
      refreshStages();
      if (removedNodes.length) {
        refreshGraph();
      }
      computeSystem();
    }

    function refreshComponents() {
      componentListEl.innerHTML = '';
      componentEmptyEl.style.display = components.length ? 'none' : 'block';

      components.forEach((comp) => {
        const card = document.createElement('div');
        card.className = 'component-card';

        const header = document.createElement('div');
        header.className = 'component-header';

        const name = document.createElement('div');
        name.className = 'component-name';
        name.textContent = comp.name;

        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.innerHTML = `A = ${formatPct(comp.availability)}`;

        header.appendChild(name);
        header.appendChild(chip);
        card.appendChild(header);

        const stats = document.createElement('div');
        stats.className = 'component-stats';
        stats.innerHTML = `
          <div>MTBF</div><div>${formatDecimal(comp.mtbf, 3)} h</div>
          <div>MTTR</div><div>${formatDecimal(comp.mttr, 3)} h</div>
          <div>Cycle Time</div><div>${formatDecimal(comp.mtbf + comp.mttr, 3)} h</div>
          <div>Downtime/yr</div><div>${hoursToHuman((1 - comp.availability) * getWindowHours())}</div>
        `;
        card.appendChild(stats);

        const actions = document.createElement('div');
        actions.className = 'actions';

        const editBtn = document.createElement('button');
        editBtn.className = 'ghost';
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', () => editComponent(comp.id));

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'Remove';
        deleteBtn.addEventListener('click', () => {
          if (confirm(`Remove ${comp.name}?`)) {
            deleteComponent(comp.id);
          }
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);
        card.appendChild(actions);

        componentListEl.appendChild(card);
      });

      refreshGraphComponentSelect();
      refreshGraph();
    }

    function addStage() {
      stages.push({
        id: nextStageId++,
        name: `Stage ${stages.length + 1}`,
        type: 'series',
        componentIds: [],
      });
      refreshStages();
      computeSystem();
    }

    function deleteStage(id) {
      const idx = stages.findIndex((s) => s.id === id);
      if (idx === -1) return;
      stages.splice(idx, 1);
      refreshStages();
      computeSystem();
    }

    function updateStageName(id, value) {
      const stage = stages.find((s) => s.id === id);
      if (!stage) return;
      stage.name = value || `Stage ${id}`;
    }

    function updateStageType(id, type) {
      const stage = stages.find((s) => s.id === id);
      if (!stage) return;
      stage.type = type === 'parallel' ? 'parallel' : 'series';
      computeSystem();
    }

    function updateStageComponents(id, selectEl) {
      const stage = stages.find((s) => s.id === id);
      if (!stage) return;
      const selected = Array.from(selectEl.selectedOptions).map((opt) => Number(opt.value));
      stage.componentIds = selected;
      computeSystem();
    }

    function refreshStages() {
      stageListEl.innerHTML = '';
      const hasDerived = derivedGraphStages.length > 0;
      stageEmptyEl.style.display = stages.length || hasDerived ? 'none' : 'block';

      stages.forEach((stage) => {
        const card = document.createElement('div');
        card.className = 'stage-card';

        const head = document.createElement('div');
        head.className = 'stage-head';

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = stage.name;
        nameInput.placeholder = 'Stage name';
        nameInput.addEventListener('input', (e) => updateStageName(stage.id, e.target.value));

        const typeSelect = document.createElement('select');
        typeSelect.innerHTML = `
          <option value="series">Series (all required)</option>
          <option value="parallel">Parallel (redundant)</option>
        `;
        typeSelect.value = stage.type;
        typeSelect.addEventListener('change', (e) => updateStageType(stage.id, e.target.value));

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => {
          if (confirm(`Delete ${stage.name}?`)) {
            deleteStage(stage.id);
          }
        });

        head.appendChild(nameInput);
        head.appendChild(typeSelect);
        head.appendChild(deleteBtn);
        card.appendChild(head);

        const selectLabel = document.createElement('label');
        selectLabel.textContent = 'Assign components to this stage';
        card.appendChild(selectLabel);

        const select = document.createElement('select');
        select.multiple = true;
        components.forEach((comp) => {
          const option = document.createElement('option');
          option.value = comp.id;
          option.textContent = `${comp.name} (${formatPct(comp.availability)})`;
          if (stage.componentIds.includes(comp.id)) {
            option.selected = true;
          }
          select.appendChild(option);
        });
        select.addEventListener('change', () => updateStageComponents(stage.id, select));
        card.appendChild(select);

        const stats = document.createElement('div');
        stats.className = 'stage-stats';
        const detail = computeStageAvailability(stage);
        stats.innerHTML = `
          <div>Availability</div><div>${formatPct(detail.availability)}</div>
          <div>Unavailability</div><div>${formatPct(detail.unavailability)}</div>
          <div>Downtime (${getWindowHours()} h)</div><div>${hoursToHuman(detail.downtimeHours)}</div>
          <div>Components</div><div>${detail.labels || '—'}</div>
        `;
        card.appendChild(stats);

        stageListEl.appendChild(card);
      });

      if (hasDerived) {
        const divider = document.createElement('div');
        divider.className = 'hint';
        divider.textContent = 'Graph-derived stages';
        stageListEl.appendChild(divider);

        derivedGraphStages.forEach((stage) => {
          const card = document.createElement('div');
          card.className = 'stage-card';
          const head = document.createElement('div');
          head.className = 'stage-head';

          const name = document.createElement('div');
          name.textContent = stage.name;
          head.appendChild(name);

          const typeBadge = document.createElement('span');
          typeBadge.className = 'chip';
          typeBadge.textContent = stage.type === 'parallel' ? 'Parallel' : 'Series';
          head.appendChild(typeBadge);

          card.appendChild(head);

          const stats = document.createElement('div');
          stats.className = 'stage-stats';
          stats.innerHTML = `
            <div>Availability</div><div>${formatPct(stage.availability)}</div>
            <div>Unavailability</div><div>${formatPct(stage.unavailability)}</div>
            <div>Downtime (${getWindowHours()} h)</div><div>${hoursToHuman(stage.downtimeHours)}</div>
            <div>Nodes</div><div>${stage.labels || '—'}</div>
          `;
          card.appendChild(stats);

          stageListEl.appendChild(card);
        });
      }
    }

    function computeStageAvailability(stage) {
      const comps = stage.componentIds
        .map((id) => components.find((c) => c.id === id))
        .filter(Boolean);
      const windowHours = getWindowHours();

      if (!comps.length) {
        return {
          availability: 1,
          unavailability: 0,
          downtimeHours: 0,
          labels: 'None selected',
        };
      }

      const values = comps.map((c) => c.availability).filter((v) => Number.isFinite(v));
      if (!values.length) {
        return {
          availability: NaN,
          unavailability: NaN,
          downtimeHours: NaN,
          labels: comps.map((c) => c.name).join(', '),
        };
      }

      let availability = 1;
      if (stage.type === 'parallel') {
        let product = 1;
        values.forEach((v) => {
          product *= 1 - v;
        });
        availability = 1 - product;
      } else {
        values.forEach((v) => {
          availability *= v;
        });
      }

      const unavailability = 1 - availability;
      const downtimeHours = unavailability * windowHours;

      return {
        availability,
        unavailability,
        downtimeHours,
        labels: comps.map((c) => c.name).join(', '),
      };
    }

    function computeSystem() {
      const windowHours = getWindowHours();
      const hasGraphTopology = graphNodes.length > 0;
      let usingGraph = false;
      let stageSummaries = [];

      if (hasGraphTopology) {
        stageSummaries = computeGraphStages(windowHours);
        usingGraph = stageSummaries.length > 0;

        if (!usingGraph) {
          systemAvailabilityEl.textContent = '—';
          systemUnavailabilityEl.textContent = '—';
          systemDowntimeEl.textContent = '—';
          systemDowntimeDetailEl.textContent = 'Add connections so the start and end terminals share at least one path.';
          systemStatusEl.textContent = 'Missing terminal connection';
          systemStatusEl.className = 'value status-warn';
          refreshStages();
          return;
        }
      } else {
        derivedGraphStages = [];
      }

      if (!usingGraph) {
        stageSummaries = stages.map((stage) => ({ stage, detail: computeStageAvailability(stage) }));
      }

      if (!stageSummaries.length) {
        systemAvailabilityEl.textContent = '—';
        systemUnavailabilityEl.textContent = '—';
        systemDowntimeEl.textContent = '—';
        systemDowntimeDetailEl.textContent = usingGraph
          ? 'Add terminals, edges, or components to the graph to define computation stages.'
          : 'Add stages to compute results.';
        systemStatusEl.textContent = 'Waiting for topology…';
        systemStatusEl.className = 'value';
        refreshStages();
        return;
      }

      if (stageSummaries.some((item) => !Number.isFinite(item.detail.availability))) {
        systemAvailabilityEl.textContent = '—';
        systemUnavailabilityEl.textContent = '—';
        systemDowntimeEl.textContent = '—';
        systemDowntimeDetailEl.textContent = 'Some stages are missing valid availability values.';
        systemStatusEl.textContent = 'Cannot evaluate';
        systemStatusEl.className = 'value status-warn';
        refreshStages();
        return;
      }

      let systemAvailability = 1;
      stageSummaries.forEach((item) => {
        systemAvailability *= item.detail.availability;
      });

      const systemUnavailability = 1 - systemAvailability;
      const downtimeHours = systemUnavailability * windowHours;

      systemAvailabilityEl.textContent = formatPct(systemAvailability);
      systemUnavailabilityEl.textContent = formatPct(systemUnavailability);
      systemDowntimeEl.textContent = `${downtimeHours.toFixed(3)} h`;
      systemDowntimeDetailEl.textContent = hoursToHuman(downtimeHours);

      const statusClass = systemAvailability >= 0.999 ? 'status-ok' : systemAvailability >= 0.99 ? 'status-warn' : '';
      systemStatusEl.textContent = systemAvailability >= 0.999 ? 'Excellent (four nines+)' : systemAvailability >= 0.99 ? 'Acceptable (three nines)' : 'Needs attention';
      systemStatusEl.className = `value ${statusClass}`.trim();

      refreshStages();
    }

    function getWindowHours() {
      const hours = parseFloat(yearHoursInput.value);
      return Number.isFinite(hours) && hours > 0 ? hours : 8760;
    }

    function resetAll() {
      if (!confirm('Clear all components and stages?')) return;
      components.splice(0, components.length);
      stages.splice(0, stages.length);
      nextComponentId = 1;
      nextStageId = 1;
      graphNodes.splice(0, graphNodes.length);
      graphEdges.splice(0, graphEdges.length);
      nextGraphNodeId = 1;
      nextGraphEdgeId = 1;
      mergeDotCount = 1;
      pendingEdgeStartId = null;
      derivedGraphStages = [];
      if (graphStartLabelInput) {
        graphStartLabelInput.value = '';
      }
      if (graphEndLabelInput) {
        graphEndLabelInput.value = '';
      }
      setGraphMode(null);
      resetForm();
      refreshComponents();
      refreshStages();
      refreshGraph();
      computeSystem();
    }

    function seedData() {
      const defaultStartLabel = 'Service Entry';
      const defaultEndLabel = 'Service Exit';
      const startLabel = graphStartLabelInput ? graphStartLabelInput.value.trim() || defaultStartLabel : defaultStartLabel;
      const endLabel = graphEndLabelInput ? graphEndLabelInput.value.trim() || defaultEndLabel : defaultEndLabel;
      if (graphStartLabelInput) {
        graphStartLabelInput.value = startLabel;
      }
      if (graphEndLabelInput) {
        graphEndLabelInput.value = endLabel;
      }

      components.push(
        { id: nextComponentId++, name: 'Edge Router A', mtbf: 1400, mttr: 2, availability: computeAvailability(1400, 2) },
        { id: nextComponentId++, name: 'Edge Router B', mtbf: 1400, mttr: 2, availability: computeAvailability(1400, 2) },
        { id: nextComponentId++, name: 'Core Switch', mtbf: 900, mttr: 4, availability: computeAvailability(900, 4) },
        { id: nextComponentId++, name: 'Firewall Cluster', mtbf: 1100, mttr: 3, availability: computeAvailability(1100, 3) },
      );

      stages.push(
        { id: nextStageId++, name: 'Dual Edge Routers', type: 'parallel', componentIds: [1, 2] },
        { id: nextStageId++, name: 'Core Switching', type: 'series', componentIds: [3] },
        { id: nextStageId++, name: 'Security Tier', type: 'series', componentIds: [4] },
      );

      const startTerminal = upsertTerminalNode('start', startLabel, 80, 200);
      const entryMerge = addMergeDotNode(320, 220);
      const routerA = addGraphNodeFromComponent(1, 160, 160);
      const routerB = addGraphNodeFromComponent(2, 160, 280);
      const core = addGraphNodeFromComponent(3, 480, 200);
      const firewall = addGraphNodeFromComponent(4, 640, 200);
      const endTerminal = upsertTerminalNode('end', endLabel, 760, 200);

      if (startTerminal && routerA) {
        graphEdges.push({ id: nextGraphEdgeId++, from: startTerminal.id, to: routerA.id });
      }
      if (startTerminal && routerB) {
        graphEdges.push({ id: nextGraphEdgeId++, from: startTerminal.id, to: routerB.id });
      }
      if (routerA && entryMerge) {
        graphEdges.push({ id: nextGraphEdgeId++, from: routerA.id, to: entryMerge.id });
      }
      if (routerB && entryMerge) {
        graphEdges.push({ id: nextGraphEdgeId++, from: routerB.id, to: entryMerge.id });
      }
      if (entryMerge && core) {
        graphEdges.push({ id: nextGraphEdgeId++, from: entryMerge.id, to: core.id });
      }
      if (core && firewall) {
        graphEdges.push({ id: nextGraphEdgeId++, from: core.id, to: firewall.id });
      }
      if (firewall && endTerminal) {
        graphEdges.push({ id: nextGraphEdgeId++, from: firewall.id, to: endTerminal.id });
      }
    }

    saveComponentBtn.addEventListener('click', upsertComponent);
    cancelEditBtn.addEventListener('click', resetForm);
    addStageBtn.addEventListener('click', addStage);
    resetAllBtn.addEventListener('click', resetAll);
    yearHoursInput.addEventListener('input', () => {
      computeSystem();
      refreshComponents();
      refreshStages();
    });
    if (graphAddStartBtn) {
      graphAddStartBtn.addEventListener('click', () => {
        const existing = getTerminalNode('start');
        if (existing && graphStartLabelInput && !graphStartLabelInput.value.trim()) {
          graphStartLabelInput.value = existing.label;
        }
        setGraphMode(graphMode === 'add-start-terminal' ? null : 'add-start-terminal');
      });
    }
    if (graphAddNodeBtn) {
      graphAddNodeBtn.addEventListener('click', () => {
        if (!components.length) {
          alert('Add components before placing nodes.');
          return;
        }
        setGraphMode(graphMode === 'add-node' ? null : 'add-node');
      });
    }
    if (graphAddEdgeBtn) {
      graphAddEdgeBtn.addEventListener('click', () => {
        if (graphNodes.length < 2) {
          alert('Create at least two nodes before connecting them.');
          return;
        }
        setGraphMode(graphMode === 'add-edge' ? null : 'add-edge');
      });
    }
    if (graphAddMergeBtn) {
      graphAddMergeBtn.addEventListener('click', () => {
        setGraphMode(graphMode === 'add-merge' ? null : 'add-merge');
      });
    }
    if (graphAddEndBtn) {
      graphAddEndBtn.addEventListener('click', () => {
        const existing = getTerminalNode('end');
        if (existing && graphEndLabelInput && !graphEndLabelInput.value.trim()) {
          graphEndLabelInput.value = existing.label;
        }
        setGraphMode(graphMode === 'add-end-terminal' ? null : 'add-end-terminal');
      });
    }
    if (graphCancelBtn) {
      graphCancelBtn.addEventListener('click', () => {
        pendingEdgeStartId = null;
        setGraphMode(null);
        refreshGraph();
      });
    }
    if (graphCanvas) {
      graphCanvas.addEventListener('click', handleCanvasClick);
    }

    seedData();
    refreshComponents();
    refreshStages();
    computeSystem();
  </script>
</body>
</html>
